{"version":3,"file":"Earth-stories.iframe.bundle.js","mappings":";;;;;;;;;;;;;;;;;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;;AAMA;;AA6BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAKA;AAEA;AAKA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAOA;;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AAIA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAOA;;;;;;;;;;;;;;;;;ACrUA;AACA;;AAGA;;AAWA;AACA;AACA;AACA;AACA;AAAA;AAUA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AAAA;AAEA","sources":["webpack://map-chart-lib/./src/Earth.stories.js","webpack://map-chart-lib/./src/components/Earth/Earth.tsx","webpack://map-chart-lib/./src/const/countryCodes.ts"],"sourcesContent":["import Earth from \"./components/Earth/Earth\";\n\nconst meta = {\n  title: \"Example/Earth\",\n  component: Earth,\n  parameters: {\n    layout: 'centered',\n  },\n  tags: ['autodocs'],\n};\n\nexport default meta;\n\nexport const Default = {\n  args: {\n    width: 800,\n    height: 800\n  },\n};\n\nexport const CustomColors = {\n  args: {\n    width: 800,\n    height: 800,\n    landColor: \"#4CAF50\",\n    oceanColor: \"#2196F3\",\n    strokeColor: \"#333\"\n  },\n}; ;export const __namedExportsOrder = [\"Default\",\"CustomColors\"];","import React, { useEffect, useRef, useState } from \"react\";\nimport { geoOrthographic, geoPath, GeoProjection } from \"d3-geo\";\nimport { feature, FeatureCollection } from \"topojson-client\";\nimport worldData from \"world-atlas/countries-110m.json\";\nimport {\n  deriveCountryKeysFromFeature,\n  pickStylesForCountry,\n} from \"../../const/countryCodes\";\nimport type * as GeoJSON from \"geojson\";\n\n// Country type (topojson feature with optional props)\ntype CountryFeature = GeoJSON.Feature<GeoJSON.Geometry, { name?: string }> & {\n  id?: string | number;\n};\n\nexport type EarthProps = {\n  width?: number;\n  height?: number;\n  landColor?: string;\n  oceanColor?: string;\n  strokeColor?: string;\n  zoomEnabled?: boolean;\n  panEnabled?: boolean;\n  lineStrong?: number;\n  lineStyle?: string;\n  lineColor?: string;\n  tooltipContent?: (name: string, country: CountryFeature) => string;\n  countryStyles?: Record<\n    string,\n    {\n      fillOpacity: null;\n      fill?: string;\n      stroke?: string;\n      strokeWidth?: number;\n      onClick?: (country: CountryFeature, name: string) => void;\n    }\n  >;\n};\n\nexport const Earth: React.FC<EarthProps> = ({\n  width = 800,\n  height = 800,\n  landColor = \"#4CAF50\",\n  oceanColor = \"#2196F3\",\n  strokeColor = \"#333\",\n  zoomEnabled = true,\n  panEnabled = true,\n  lineStrong = 0.1,\n  lineStyle = \"solid\",\n  lineColor = \"#000\",\n  tooltipContent = () => \"\",\n  countryStyles = {},\n}) => {\n  const canvasRef = useRef<HTMLCanvasElement | null>(null);\n  const rotationRef = useRef<[number, number]>([0, -30]);\n  const scaleRef = useRef<number>(1);\n  const isDragging = useRef<boolean>(false);\n  const lastPos = useRef<[number, number]>([0, 0]);\n\n  const [tooltip, setTooltip] = useState<{\n    visible: boolean;\n    x: number;\n    y: number;\n    content: string;\n  }>({\n    visible: false,\n    x: 0,\n    y: 0,\n    content: \"\",\n  });\n\n  const [hoveredCountry, setHoveredCountry] = useState<CountryFeature | null>(\n    null\n  );\n\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const context = canvas.getContext(\"2d\");\n    if (!context) return;\n\n    const baseScale = height / 2.2;\n    const projection: GeoProjection = geoOrthographic()\n      .scale(baseScale * scaleRef.current)\n      .translate([width / 2, height / 2])\n      .rotate(rotationRef.current);\n\n    const path = geoPath().projection(projection).context(context);\n\n    const countries: CountryFeature[] = feature(\n      worldData as any,\n      (worldData as any).objects.countries\n    ).features as CountryFeature[];\n\n    function drawGlobe() {\n      if (!context) return;\n      context.clearRect(0, 0, width, height);\n\n      // Okyanus\n      context.beginPath();\n      context.fillStyle = oceanColor;\n      context.arc(\n        width / 2,\n        height / 2,\n        projection.scale() || 0,\n        0,\n        2 * Math.PI\n      );\n      context.fill();\n\n      // Sphere Ã§izimi\n      context.beginPath();\n      path({ type: \"Sphere\" });\n      context.strokeStyle = strokeColor;\n      context.lineWidth = 0.5;\n      context.stroke();\n\n      countries.forEach((feature, i) => {\n        const id = feature.id || `country-${i}`;\n        const derived = deriveCountryKeysFromFeature(feature);\n        const styles = pickStylesForCountry(countryStyles, derived);\n\n        context.beginPath();\n        path(feature);\n\n        let fillColor = styles.fill || landColor;\n        if (hoveredCountry && hoveredCountry.id === id) {\n          fillColor = styles.fill || landColor;\n          context.globalAlpha = 0.8;\n        }\n\n        context.fillStyle = fillColor;\n        context.fill();\n        context.globalAlpha = 1.0;\n\n        context.strokeStyle = styles.stroke || strokeColor;\n        context.lineWidth = styles.strokeWidth || 0.3;\n        context.stroke();\n      });\n    }\n\n    let animationId: number;\n    function animate() {\n      const rot = rotationRef.current;\n      rot[0] += 0.2;\n      projection.rotate(rot);\n      projection.scale(baseScale * scaleRef.current);\n      drawGlobe();\n      animationId = requestAnimationFrame(animate);\n    }\n    animate();\n\n    const getMousePos = (e: MouseEvent) => {\n      const rect = canvas.getBoundingClientRect();\n      return {\n        x: e.clientX - rect.left,\n        y: e.clientY - rect.top,\n      };\n    };\n\n    const getCountryAtPoint = (x: number, y: number) => {\n      const point = projection.invert([x, y]);\n      if (!point) return null;\n\n      for (let i = 0; i < countries.length; i++) {\n        const country = countries[i];\n        if (path.area(country) > 0) {\n          context.save();\n          context.beginPath();\n          path(country);\n          if (context.isPointInPath(x, y)) {\n            context.restore();\n            return country;\n          }\n          context.restore();\n        }\n      }\n      return null;\n    };\n\n    const handleMouseDown = (e: MouseEvent) => {\n      const mousePos = getMousePos(e);\n      const country = getCountryAtPoint(mousePos.x, mousePos.y);\n\n      if (country) {\n        const id = country.id || `country-${countries.indexOf(country)}`;\n        const derived = deriveCountryKeysFromFeature(country);\n        const styles = pickStylesForCountry(countryStyles, derived);\n        if (styles.onClick) {\n          const name = country.properties?.name || `Country ${id}`;\n          styles.onClick(country, name);\n        }\n      }\n\n      isDragging.current = true;\n      lastPos.current = [e.clientX, e.clientY];\n    };\n\n    const handleMouseMove = (e: MouseEvent) => {\n      if (!isDragging.current) {\n        const mousePos = getMousePos(e);\n        const country = getCountryAtPoint(mousePos.x, mousePos.y);\n\n        if (country) {\n          const name = country.properties?.name || `Country ${country.id}`;\n          setTooltip({\n            visible: true,\n            x: e.clientX,\n            y: e.clientY,\n            content: tooltipContent(name, country),\n          });\n          setHoveredCountry(country);\n        } else {\n          setTooltip((prev) => ({ ...prev, visible: false }));\n          setHoveredCountry(null);\n        }\n        return;\n      }\n\n      const dx = e.clientX - lastPos.current[0];\n      const dy = e.clientY - lastPos.current[1];\n      lastPos.current = [e.clientX, e.clientY];\n      rotationRef.current[0] += dx * 0.5;\n      rotationRef.current[1] -= dy * 0.5;\n    };\n\n    const handleMouseUp = () => {\n      isDragging.current = false;\n    };\n\n    const handleMouseLeave = () => {\n      isDragging.current = false;\n      setTooltip((prev) => ({ ...prev, visible: false }));\n      setHoveredCountry(null);\n    };\n\n    const handleWheel = (e: WheelEvent) => {\n      e.preventDefault();\n      const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;\n      scaleRef.current *= zoomFactor;\n      scaleRef.current = Math.max(0.5, Math.min(3, scaleRef.current));\n    };\n\n    // Event binding\n    canvas.addEventListener(\"mousedown\", handleMouseDown);\n    canvas.addEventListener(\"mousemove\", handleMouseMove);\n    canvas.addEventListener(\"mouseup\", handleMouseUp);\n    canvas.addEventListener(\"mouseleave\", handleMouseLeave);\n    canvas.addEventListener(\"wheel\", handleWheel);\n\n    // Touch events\n    canvas.addEventListener(\"touchstart\", (e) => {\n      e.preventDefault();\n      isDragging.current = true;\n      const touch = e.touches[0];\n      lastPos.current = [touch.clientX, touch.clientY];\n    });\n\n    canvas.addEventListener(\"touchmove\", (e) => {\n      e.preventDefault();\n      if (!isDragging.current) return;\n      const touch = e.touches[0];\n      const dx = touch.clientX - lastPos.current[0];\n      const dy = touch.clientY - lastPos.current[1];\n      lastPos.current = [touch.clientX, touch.clientY];\n      rotationRef.current[0] += dx * 0.5;\n      rotationRef.current[1] -= dy * 0.5;\n    });\n\n    canvas.addEventListener(\"touchend\", (e) => {\n      e.preventDefault();\n      isDragging.current = false;\n    });\n\n    return () => {\n      cancelAnimationFrame(animationId);\n      canvas.removeEventListener(\"wheel\", handleWheel);\n      canvas.removeEventListener(\"mousedown\", handleMouseDown);\n      canvas.removeEventListener(\"mousemove\", handleMouseMove);\n      canvas.removeEventListener(\"mouseup\", handleMouseUp);\n      canvas.removeEventListener(\"mouseleave\", handleMouseLeave);\n    };\n  }, [\n    width,\n    height,\n    landColor,\n    oceanColor,\n    strokeColor,\n    tooltipContent,\n    countryStyles,\n    hoveredCountry,\n  ]);\n\n  return (\n    <div style={{ position: \"relative\", width, height }}>\n      <canvas ref={canvasRef} width={width} height={height} />\n\n      {tooltip.visible && (\n        <div\n          style={{\n            position: \"absolute\",\n            top:\n              tooltip.y -\n              (canvasRef.current?.getBoundingClientRect().top || 0) +\n              10,\n            left:\n              tooltip.x -\n              (canvasRef.current?.getBoundingClientRect().left || 0) +\n              10,\n            background: \"rgba(0, 0, 0, 0.7)\",\n            color: \"#fff\",\n            padding: \"6px 10px\",\n            borderRadius: \"4px\",\n            pointerEvents: \"none\",\n            fontSize: \"14px\",\n            maxWidth: \"200px\",\n            zIndex: 10,\n          }}\n        >\n          {tooltip.content}\n        </div>\n      )}\n    </div>\n  );\n};\n","import countries from \"i18n-iso-countries\";\nimport enLocale from \"i18n-iso-countries/langs/en.json\";\nimport type { Feature } from \"geojson\";\n\n// Country styles tip tanÄ±mÄ±\nexport interface CountryStyle {\n  fillOpacity: null;\n  fill?: string;\n  stroke?: string;\n  strokeWidth?: number;\n  onClick?: (feature: Feature, name: string) => void;\n}\n\nexport type CountryStylesMap = Record<string, CountryStyle>;\n\n// Register English locale for i18n-iso-countries lookups\ntry {\n  countries.registerLocale(enLocale);\n} catch {\n  // Zaten kayÄ±tlÄ±ysa hata yutulur\n}\n\nexport interface DerivedCountryKeys {\n  id: string;\n  numeric3: string;\n  alpha2?: string;\n  alpha3?: string;\n}\n\nexport function deriveCountryKeysFromFeature(countryFeature: Feature): DerivedCountryKeys {\n  const rawId = (countryFeature as any)?.id;\n  const idAsString = rawId != null ? String(rawId) : \"\";\n  const numeric3 = idAsString.padStart(3, \"0\");\n\n  let alpha2: string | undefined;\n  let alpha3: string | undefined;\n\n  try {\n    alpha2 = countries.numericToAlpha2(numeric3);\n  } catch {\n    alpha2 = undefined;\n  }\n\n  try {\n    alpha3 = alpha2 ? countries.alpha2ToAlpha3(alpha2) : undefined;\n  } catch {\n    alpha3 = undefined;\n  }\n\n  return {\n    id: idAsString,\n    numeric3,\n    alpha2,\n    alpha3,\n  };\n}\n\nexport function pickStylesForCountry(\n  countryStyles: CountryStylesMap | undefined,\n  derivedKeys: DerivedCountryKeys\n): CountryStyle {\n  if (!countryStyles || typeof countryStyles !== \"object\") return {\n  fillOpacity: null\n};\n\n  const tryKey = (keyCandidate?: string) => {\n    if (!keyCandidate) return undefined;\n    if (countryStyles[keyCandidate] != null) return countryStyles[keyCandidate];\n    const upper = keyCandidate.toUpperCase();\n    const lower = keyCandidate.toLowerCase();\n    if (upper && countryStyles[upper] != null) return countryStyles[upper];\n    if (lower && countryStyles[lower] != null) return countryStyles[lower];\n    return undefined;\n  };\n\n  return (\n    tryKey(derivedKeys.alpha2) ||\n    tryKey(derivedKeys.alpha3) ||\n    tryKey(derivedKeys.numeric3) ||\n    tryKey(derivedKeys.id) ||\n    { fillOpacity: null }\n  );\n}\n"],"names":[],"sourceRoot":""}